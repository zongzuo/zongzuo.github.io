---
layout: default
---
# 清华大学C++自主学习课程
简略笔记

### 2-1 导学
数据类型：整数 实数 字符 布尔

### 2-2 C++特点和词法记号大纲
从C来(最早叫C with class)  
本门课讲述C++11  
语言特点：尽量兼容C，同时面向对象  
程序实例  
```cpp
#include <iostream>  // 编译预处理文件 （相当于复制粘贴iostream中的内容过来）
using namespace std;  // 命名空间避免命名冲突
int main() {
    cout << "Hello!" << endl;  // << 是流插入运算  cout 负责向显示器输出流发送字符
    return 0; // 默认返回结果给调用者（比如操作系统）
}
```

### 2-3 基本字符集和词法记号
关键字 标识符 文字 分隔符 运算符 空白符


### 2-3-1 数据类型 常量 变量
C++标准没规定int多少字节，只规定了long short 等与他们的关系  
C++用string表示字符串  
C风格的字符串  
变量的定义，可在定义时初始化。初始化不许信息丢失，如用float初始化一个int变量  

符号常量必须定义时初始化，之后不能改变  

### 2-3-2 例子
浮点数在计算机中是近似保存的，不应直接判断相等而是判断差的绝对值足够小

### 2-4-1 算术运算与算术表达式
```cpp
+ - * / %
++ -- //前置，后置
```
赋值，复合赋值运算符：
```cpp
+= -= %= <<= &=
```

### 2-4-2 逗号运算符，关系运算符逻辑运算符和条件运算符


### 2-4-3 sizeof运算符 位运算
```cpp
<< ^ & |
```

### 2-4-4 运算优先级 类型转换
隐含转换 从低到高  
cpp推荐，类型转换操作符\<类型说明符\>\(表达式\)，初期阶段用 static\_cast 就行了

### 2-5 数据输入输出

### 2-6 选择结构
```cpp
if (x > y) cout << x;  

if (x > y) cout << x;  
else cout << y;  
```
```cpp
if (表达式1) 语句1  
else if (表达式2) 语句2  
else 语句n
```  

如果有嵌套的if else，else会找最近的if

### 2-7-1 循环结构 while
先判断循环条件

### 2-7-2 Do-While
先执行一次再看是否满足循环条件

### 2-7-3 for语句
```
for(循环前先求解，只进行一次;为true时执行循环;每次执行完循环体后求解)  
```

用于容器：  
```
for(声明: 表达式)  
  语句  
```
### 2-7-4 嵌套循环、其他控制语句
break: 退出最内层循环  
continue: 结束当前循环，但继续判断是否下次循环  
goto: 避免使用  


### 2-8 自定义类型
typedef 已有类名 新类名  
using 新类名 = 已有类名  

(不限定作用域)  
```cpp
enum 枚举类型名 {变量值列表}  
```
例如：  
```cpp
enum Weekday {SUN, MON, TUE, WEB, THU, FRI, SAT};
```
枚举元素为常量，不可赋值  
默认值0,1,2,3,4，也可以声明时自己指定  
枚举值可进行关系运算  
枚举值可以赋给整形变量，整形不能直接赋给枚举变量  

auto: 编译器通过初始值自动推断变量类型  
decltype: 定义一个变量与某表达式类型相同，但并不用该表达式初始化变量  
如: decltype(i) j = 2 表示j以2作初始值，类型与i一致。

### 2-9 switch
```cpp
switch(iType)
{
case 1:
  xxx
  break;
case2:
  xxx
  break;
default:
  xxx
}
```

### 3-1 函数导学
- 函数定义与调用
- 内联函数
- constexpr函数
- 带默认参数值的函数
- 函数重载
- C++系统函数

### 3-2 函数定义
```cpp
类型标识符 函数名(形式参数表)
{
  语句序列 // 最后一句是return语句, void可以不写
}
```
形式参数调用时不占存储空间，只有调用时才会分配

### 3-3-1 函数调用大纲
调用前需要声明函数原型  
```cpp
类型标识符 被调用函数名(含类型说明的形参表)
```
调用形式：
```cpp
函数名(实际参数列表) // 此时为变量分配空间
```
可以嵌套调用，递归等

### 3-3-2/3/4/5 功能拆分写函数实现的例子

### 3-4-1 函数嵌套调用大纲

### 3-4-2 函数递归调用大纲
直接或间接地调用自身  
例子: 阶乘，组合数，汉诺塔

### 3-5 函数的参数传递
如果实参形参类型不同，编译器会首先尝试做隐含类型转换，失败就会编译器报错。  
单向传递(实参的值作为初始化参数给形参后，函数内外变量从此切断联系)，函数内修改不会影响外部  
传递引用可以保证双向传递  
传引用的开销比传值小, 尤其是参数是一个比较大的对象的时候  
常引用作参数可以保证实参数据的安全  


### 3-6 引用类型
```cpp
int i;
int &ri = i;  // 定义int引用ri，并初始化为变量i的引用
```
定义引用必须同时进行初始化，使其指向一个已经存在的对象  
此后，ri与i指向同一个变量，对其中任何一个改变都会影响另一个。  
一旦一个引用被初始化，就无法改为指向其它对象    

引用可以用作形参

### 3-7 含有可变参数的函数
C++表中提供了两种主要方法。
- 如果所有实参类型相同，可以传递一个名为initializer\_list的标准库类型
- 如果实参类型不同，我们可以编写可变参数的模板

initializer\_list是标准库类型，用于表示某种特定类型的值的数组，该类型定义在同名头文件中  
initializer\_list<string> ls;  
initializer\_list对象中的元素永远是常量值，无法改变  
含有initializer\_list形参的函数也可以同时拥有其他形参  

### 3-8 内联函数
由编译器实现，跳过转子函数和返回的开销  
告诉编译器用函数体内语句替换函数调用  

需要注意的是：  
1. 内联函数体内不能有循环和switch
2. 内联函数定义必须出现在第一次被调用之前
3. 内联函数内不能进行异常接口声明

inline只是建议，编译器会自行判断，编译器会自动把足够简单的函数变成内联  

### 3-9 constexpr函数
constexpr修饰的函数在起所有参数都是constexpr时一定返回constexpr ?????  只允许有一条return语句
```cpp
constexpr int get_size() {return 20;}
constexpr int foo = get_size();
```

### 3-10-1 带默认参数值的函数
实参个数不定，按顺序形实结合

### 3-11 函数重载
多态性的一个重要机制，静态多态性机制，编译时实现。  
允许功能相近的函数在相同作用域内以相同函数名声明  
```cpp
int add(int x, int y);
int add(float x, float y);
int add(int x, int y, int z);
```
编译器以参数的个数和类型决定调用哪个，不以返回值，形参名决定  
不要用不同功能函数声明为重载防止误解混淆  

### 3-12 C++系统函数
例如: sqrt abs 需要包含对应的头文件如cmath 

### 3-13 小结
应掌握:
- 函数的定义，调用，参数传递
- 内联函数，带默认参数值的函数，函数重载
- C++系统函数

### 4-1 类与对象导学
对象: 现实中对象的模拟，具有属性和行为  
类: 同一类对象的共同属性和行为

### 4-2 面向对象程序的基本特点
1. 抽象：对同类对象共同属性和行为进行概括，形成类  
- 先注意问题本质和描述，其次才是实现过程或细节
- 数据抽象：描述某类对象的属性或状态
- 代码抽象：描述某类对象的共有行为特征或具有的功能
- 抽象的实现：类

2. 封装：将抽象出的数据，代码封装在一起形成类  
- 姜抽象出的数据成员代码成员相结合，将他们视为一个整体。
- 目的：增强安全性，简化变成，使用者不必了解具体实现细节，而只需要通过外部借口以特定访问权限来使用类成员
- 实现封装：类声明中的\{\}

```cpp
class Clock{
  public: void setTime(int newH, int newM, int newS);
          void showTime();
  private: int hour, minute, second;
}
```

3. 继承：在已有类的基础上进行扩展形成新的类
4. 多态：同一名称，不同的功能实现方式
- 目的：达到行为标识统一，减少程序中的标识符个数

### 4-3-1 类和对象的定义
设计类就是设计类型  
- 此类型"合法值"是什么
- 应有什么样的函数，操作符
- 新类型的对象该如何被创建和销毁
- 如何进行对象初始化和赋值
- 对象作为参数的参数如何以值传递
- 谁将使用此类型的对象成员

语法：  
```cpp
class 类名
{
  public:
    公有成员(外部接口)
  private:
    私有成员
  protected:
    保护型成员
}
```
可以进行类内初始化
```cpp
class Clock{
  public: void setTime(int newH, int newM, int newS);
          void showTime();
  private: int hour=0, minute=0, second=0;
}
```

- 公有成员是类与外部的借口，任何外部函数都能访问公有类型数据和函数
- 私有类型成员只允许本类中函数访问，而类外部任何函数都不能访问； 如果紧跟在类名称后面声明私有成员，则关键字private可省略
- 保护成员与private类型类似，差别表现在继承和派生时对派生类的影响。

定义对象的语法：
```cpp
类名 对象名;
```

类成员之间可以直接用成员名互相访问

从类外访问成员需要使用"对象名\.成员名"方式访问public成员

类的成员函数：  
- 在类中声明函数原型；
- 可在类外给出函数体实现，并在函数名前使用类名加以限定
- 也可直接在类中给出函数体，形成内联成员函数
- 允许声明重载函数和带默认参数值的函数

内联成员函数：  
- 为提高运行效率，对于简单函数可以声明为内联
- 内联函数体重不要有循环或switch等复杂结构
- 方式: 姜函数体放在类声明中；在类声明外，使用inline关键字

### 4-3-2 类和对象程序例子
```cpp
void Clock::setTime(int newH, int newM, int newS) {
  hour = newH;
  minute = newM;
  second = newS;
}
void Clock::showTime() {
  cout << hour << ":" << minute << ":" << second;
}
```
```cpp
int main() {
  Clock myClock;
  myClock.setTime(8, 30, 30);
  myClock.showTime();
  return 0;
}
```

### 4-4-1 构造函数
- 类中的特殊函数
- 用于描述初始化算法

形式：  
- 函数名与类名相同
- 不能定义返回值类型，void也不行，不应该return
- 可有形参
- 可内联，可重载，可带默认值

在对象创建时被自动调用，不需要显式调用  

默认构造函数：构造函数参数表为空或者全部参数都带有默认值  

构造函数不能有歧义，如：  
```cpp
Clock();
Clock(int newH = 0, int newM = 0; int newS = 0);
```

隐含生成的构造函数：  
- 如果不声明构造函数，编译器编译时会自动生成隐含的默认构造函数
- 参数列表为空，不给数据成员设初始值
- 若类内定义了成员初始值的话，就用
- 如果无定义，则以默认方式初始化
- 基本类型数据默认初始化的值是不确定的

"=default":  
- 若程序中已有构造函数，默认情况下编译器不再隐含生成默认构造函数。若依然希望编译器生成隐含生成默认构造函数可以：
```cpp
class Clock(){
  public:
    Clock() = default;
    Clock(int newH, int newM, int newS);
  private:
    int hour, minute, second;
}
```

### 4-4-2 构造函数例子
```cpp
Clock::Clock(int newH, int newM, int newS):
  hour(newH), minute(newM), second(newS){  // 此为初始化列表，比在函数体中写赋值效率更高
}
```
经常需要在自己的构造函数之外手动写一个默认构造函数(Convention，方便其他人，防止其他人用默认没有对应的默认构造函数)
```cpp
Clock::Clock(): hour(0), minute(0) second(0){}
```

### 4-4-4 委托构造函数
- 为了避免多个构造函数的重载的函数体相同，代码重复的问题。委托构造函数实现这个功能。
- 委托构造函数使用类的其他构造函数执行初始化过程
例如：  
```cpp
Clock(int newH, int newM, int newS):
hour(newH), minute(newM), second(newS){
}
Clock():Clock(0,0,0){}
```

### 4-4-5 复制构造函数
- 用已有对象初始化新对象，就需要用到复制构造函数
- 如果不定义复制构造函数，编译器会默认生成。默认会一一对应地复制对象的成员，如果满意，就可以不写复制构造函数。否则需要自己实现。

复制构造函数定义  
复制构造函数是特殊的构造函数，其形参为本类的对象引用。作用是用一个已存在的对象去初始化同类型新对象。

```cpp
class 类名 {
public:
类名(形参); // 构造函数
类名(const 类名 &对象名); // 复制构造函数
//...
}
类名::类名 (const 类名 &对象名) // 复制构造函数的实现
{函数体}
```

复制构造函数被调用的三种情况：  
- 定义一个对象时，以本类另一个对象作为初始值，发生复制构造；
- 如果函数的形参是类的对象，调用函数时，将使用实参对象初始化形参对象时，发生复制构造；
- 如果函数返回值是类的对象，函数执行完成返回主调函数时，将使用return语句中的对象初始化一个临时无名对象，传递给主调函数，此时发生复制构造函数。（但这种情况也可以通过移动构造来避免不必要的复制）


隐含的复制构造函数 （很多简单的时候够用了）  
- 若程序猿没有为类声明拷贝初始化构造函数，则编译器自己生成一个隐含复制构造函数
- 它会用初始值对象的每个数据成员初始化即将要简历的对象的对应数据成员

"=delete"  
如果不希望对象被复制构造，C++11：用"=delete"指示编译器不生成默认复制构造函数
例子：  
```cpp
class Point {
public:
  Point(int xx=0, int yy=0) {x = xx; y = yy;} // 构造函数，内联
  Point(const Point& p) =delete; //指示编译器不生成默认复制构造函数
private:
  int x, y;
}
```

### 4-4-6
```cpp
Point a;
Point b(a);

b = fun2(); // fun2返回一个Point类型的对象
// 这里是赋值不是构造，赋值时不会发生复制构造，而是用赋值操作实现的
```

### 4-5 析构函数
- 对象生存期结束时系统自动调用析构函数  
- 析构函数完成对象被删除前的一些清理工作  
- 如果程序中未声明析构函数，编译器会自动产生默认析构函数，其函数体为空。

析构函数原型 \~类名();
析构函数没有参数表，没有返回类型

```cpp
class Point {
public:
  Point(int xx, int yy);
  ~Point();
  //
private:
  int x, y;
};

Point::~Point(){} // 如果是自动生成的和这个类似
```


### 4-6-1 组合类
组合的概念  
- 类中的成员是另一个类的对象
- 可以在已有对象基础上实现更复杂的抽象

类组合的构造函数设计  
- 原则：不仅要负责对本类中的基本类型成员数据初始化，也要对对象成员初始化
- 声明形式：  
```cpp
类名::类名(对象成员所需的形参，本类成员形参):
  对象1(参数), 对象2(参数), ....
{
// 其他语句
}
```
构造组合类对象时的初始化次序  
1. 构造函数初始化列表中列出成员，初始化次序是成员在类体中定义的次序
- 成员对象构造函数调用顺序依照他们在类体中定义的顺序。
- 初始化列表中未出现的成员对象，调用默认构造函数（也解释了之前提到的为什么需要实现一个默认构造函数）

2. 处理完初始化列表后，再执行构造函数的函数体


### 4-6-3 前向引用申明
解决两个类互相引用的问题

- 类应该先声明后使用
- 如果需要在某类声明之前，引用该类，则应该进行前向引用申明
- 前向引用申明只为程序引入一个标识符，但具体声明在别的地方

使用时需要注意：  
- 提供完整类声明之前，不能声明该类的对象，也不能在内联成员函数中使用该类的对象
- 当使用前向引用声明时，只能使用被声明的符号，而不能涉及任何的细节

```cpp
class B; //前向引用申明
class A {
public:
  void f(B b);
};
class B {
public:
  void g(A a);
}
```


### 4-7 UML
三个基本部分:  
事物 关系 图  
用来描述类之间的关系


### 4-8-1 结构体
C++中的结构体是一种特殊形态的类  
与类的唯一区别：
- 类的缺省访问权限是private
- 结构体缺省访问权限是public

什么时候用结构体而不是用类：
- 定义主要用来保存数据，而没有什么操作的类型
- 人们习惯将结构体的数据成员设为公有，因此这时用结构体更方便

结构体的定义：
```cpp
struct 结构体名称{
  公有成员
protected:
  保护型成员
private:
  私有成员
};
```
结构体中可以有数据成员和函数成员（C语言中只能有数据成员）

结构体的初始化  
如果：
- 一个结构体全部数据成员都是公共成员；
- 没有用户定义的构造函数；
- 没有基类和虚函数（基类和虚函数第七章介绍）
那么这个结构体变量可以用下面语法形式初始化：
```cpp
类型名 变量名 = {成员数据1初值, 成员数据2初始, ...}；
```

### 4-8-2 联合体
和类和结构体很像，但是会做到空间的共用
```cpp
union 联合体名称{
  公有成员
protected:
  保护型成员
private:
  私有成员
};
```
特点：  
- 所有成员共用同一组内存单元  
- 任何两个成员不会同时有效  
- 按占用最多的成员分配空间

无名联合体

### 4-9 枚举类
- 也称强类型的枚举
- 之前的enum是整数的子集，在cpp中引入了枚举类

语法形式：  
```cpp
enum class 枚举类型名: 底层类型 {枚举值列表};
```
如果不定义底层类型，默认底层类型为整数  
例如：
```cpp
enum class Type {General, Light, Medium, Heavy};
enum class Type:char {General, Light, Medium, Heavy};
enum class Category {General=1, Pistol, MachineGu, Cannon};

```

相比于从C中继承过来的enum，枚举类的优势：
- 强作用域：Type::General而不能直接用General了
- 转换限制：枚举类对象不能和整型隐式地相互转换
- 可以指定底层类型

就算底层类型相同，也不能进行比较，编译器会因不为同一类而报错

### 4-10 本章小节
主要内容：
- 面向对象基本概念
- 类和对象的申明
- 构造函数
- 析构函数
- 内敛成员函数
- 复制构造函数
- 类的组合
- 结构体
- 联合体
- 枚举类
- UML


### 5-1 数据共享与保护导学
变量和对象定义在不同的位置  
（函数体内，类体内，函数原型参数表内，所有函数和类之外）  
其作用域，可见性，生存周期都不同

属于整个类的数据成员（例如，线段类的总个数）：静态数据成员  

用于处理静态数据成员的函数：静态函数成员  

友元：  
  >（如果需要访问类的数据，而频繁访问公有接口函数，会有较大的计算开销，因此）  
  对一些类外的函数，其他的类，给予授权，使之可以访问类的私有成员  
  但同时也会带来数据安全性问题，使用常类型解决  

更多编译预处理  
多文件结构  


### 5-2 标识符的作用域和可见性
作用域分类：
- 函数原型作用域
- 局部作用域（块作用域）
- 类作用域
- 文件作用域
- 命名空间作用域（详见第十章）

函数原型作用域：  
- 函数原型中的参数
- 其作用域始于形参表的“(”，结束于形参表的“)”
  例子：
```cpp
double area(double radius);
```

局部作用域：  
- 函数的形参，在块中声明的标识符；
- 作用域自声明处起，限于块中。（例如函数体，循环体）  

类作用域：
- 类的成员具有类作用域，其范围包括类体和成员函数体
- 在类作用域以外访问类的成员：
  - 静态成员：通过类名，或者该类对象名，对象引用 访问
  - 非静态成员：通过类名，或者该类的对象名，对象引用，对象指针 访问  

文件作用域：（也称为静态作用域）
- 不再上述情况中的生命，就具有文件作用域
- 作用域始于声明点，结束于文件尾。


可见性：
- 可见性是从对标识符引用的角度来谈的
- 可见性表示从内层作用域向外层作用域“看”时能看见什么
- 如果标识在某处可见，就可以在此处引用该标识符。否则即使在作用域内也无法使用

命名空间作用域 包含 类作用域 包含 块作用域  

可见性：
- 如果某个标识符在外层中声明，且内层中没有同一标识符声明，则该标识符在内层可见。
- 对于两个嵌套作用域，如果在内层作用域内声明了与外层作用域中的同名标识符，则外层作用域的标识符在内层不可见。（但仍然在作用域内）

例子：
```cpp
#include<iostream>
using namespace std;

int i; //全局变量，文件作用域

int main(){
  i = 5; //为全局变量i赋值
  {
    int i; // 局部变量，局部作用域
    i = 7;
    cout << i << endl; // 输出7
  }
  cout << i << endl; // 输出5
}
```

### 5-3 对象的生存期
对象的生存期
- 对象从产生到结束的这段时间就是生存期
- 在对象生存期内，对象将保持它的值，直到被更新为止

分为：
1. 静态生存期：
- 与程序的运行期相同
- 在文件作用域中声明的对象具有这种生存期
- 在函数内部声明静态生存期对象，要冠以static关键字
- 一直存续，哪怕退出了作用域，存储空间也不会被释放，在重新回到作用域时任然可以找到上次离开时的值  

2. 动态生存期：
- 开始于程序执行到声明点时，结束于命名该标识符的作用域结束处
- 块作用域中声明的，没有用static修饰的对象，就是动态生存期对象（习惯称为局部生存期对象）
- 一旦离开作用域后就消亡，在重新回到作用域时，需要重新分配空间，重新初始化  

```cpp
#include<iostream>
using namespace std;
int i = 1; // i为全局变量，具有静态生存期
void other(){
  static int a = 2;
  static int b; //
  // a,b为静态局部变量，具有全局寿命，局部可见
  // 只第一次进入函数时被初始化
  int c = 10; // C为局部变量，具有动态生存期，
              // 每次进入函数时都会被初始化
  a += 2; i += 32; c += 5;
  cout << i << a << b << c << endl;
  b = a;
}
```
静态局部变量和局部变量的存储位置是不同的，静态局部变量默认初始化，初始值是0（例子中是static int，不知道其他类型会不会也是0呢）



### 5-4 静态数据成员
- 用关键字static声明
- 为该类的所有对象共享，静态数据成员具有静态生存期
- 必须在类外定义和初始化，用(::)来指明所属的类

```cpp
#include<iostream>
using namespace std;
class Point { // Point类定义
public:  //外部接口
  Point(int x = 0, int y = 0): x(x), y(y) { // 构造函数
    count ++; // 在构造函数中对count累加，所有对象共同维护同一个count
  }
  Point(Point &p) {  // 复制构造函数
    x = p.x; y = p.y; count ++;
  }
  ~Point() {count--;}
  int getX() {return x;}
  int getY() {return y;}
  void showCount{ // 输出静态数据成员
    cout << cout << endl;
  }
private: //私有数据成员
  int x,y;
  static int count; //静态数据成员声明，用于记录点个数
};
int Point::count = 0; // 静态数据成员定义和初始化必须在类体外，使用类名限定

int main() {
  Point a(4,5);
  cout << a.getX() << a.getY() << endl;
  a.showCount();

  Point b(a);
  cout << b.getX() << b.getY() << endl;
  b.showCount();
  return 0;
}
```
问题来了：如果我一个点对象都没有构造，如何告诉我点的个数呢，因为访问showCount必须通过对象。后面有办法解决


### 5-5 静态函数成员
和函数成员的区别在于：进入函数体后，能否知道是哪个对象在调用它  
所以静态函数成员不用来处理和对象有关的数据成员，而只处理静态数据成员  

如果非要在静态函数成员中访问非静态成员，就需要通过对象来访问

```cpp
#include<iostream>
using namespace std;
class Point {
public:
  Point(int x = 0, int y = 0): x(x), y(y) { // 构造函数
    count ++; // 在构造函数中对count累加，所有对象共同维护同一个count
  }
  Point(Point &p) {  // 复制构造函数
    x = p.x; y = p.y; count ++;
  }
  ~Point() {count--;}
  int getX() {return x;}
  int getY() {return y;}
  static void showCount{ // 输出静态数据成员
    cout << cout << endl;
  }
private: //私有数据成员
  int x,y;
  static int count; //静态数据成员声明，用于记录点个数
};
```

### 5-6 类的友元
- 友元是C++提供的一种破坏数据封装和数据隐藏的机制
- 通过将一个模块声明为另一个模块的友元，一个模块能够引用到另一个模块中本是被隐藏的信息
- 可以声明友元函数和友元类
- 为了确保数据的完整性，以及数据封装与隐藏规则，建议慎用友元

友元函数
- 友元函数是在类声明中由关键字friend修饰说明的非成员函数，在它的函数体中能够通过对象名访问private和protected成员。
- 作用：增加灵活性，使程序员可以在封装和快速性方面做合理选择
- 访问对象中的成员必须通过对象名

\[此处视频缺失，内容不全\]

### 5-7 共享数据的保护
常类型：
- 常对象：必须进行初始化，不能被更新。const 类名 对象名;
- 常成员：用const进行修饰的类成员：常数据成员和常函数成员。
- 常引用：被引用的对象不能被更新。const 类型说明符 \&引用名;
- 常数组： 数组元素不能被更新：类型说明符 const 数组名\[大小\]
- 常指针：指向常量的指针

常对象：用const修饰的对象
例如：
```cpp
class A {
public:
A(int i, int j) {x=i; y=j;}
private:
int x, y;
};

A const a(3,4); //a为常对象，不能被更新
```

常成员：用const修饰的对象成员
1. 常成员函数
- 使用const关键字说明
- 常成员函数不更新对象的数据成员
- 格式：
  类型说明符 函数名 (参数表) const;
  这里，const是函数类型的一个组成部分，因此实现时也需要带const关键字
- const关键字可以用于参与对重载函数的区分
- 通过常对象只能调用它的常成员函数
2. 常数据成员
- 使用const说明的数据成员

例子
一个类定义了 void print();和 void print() const;
那么一个常对象就会调用常函数

将不会改变对象状态的函数声明为const是好习惯

常引用：相当于只读，做参数可以保证高效率和实参安全性

### 5-8 多文件结构和编译预处理命令
C++程序的一般组织结构  
一个工程可以划分为多个源文件，例如：
- 类声明文件(.h)
- 类实现文件(.cpp)
- 类的使用文件(main()所在的.cpp文件)
  利用工程来组合各个文件

外部变量
- 除了在定义它的源文件中可以使用外，还可以被其他文件使用
- 文件作用域中定义的变量，默认情况下都是外部变量
- 在其他文件中如果需要使用，需要用extern关键字声明

外部函数
- 在所有类之外声明的函数（即非成员函数），都是具有文件作用域的
- 这样的函数都可以在不同的编译单元中被调用
- 只要在调用之前进行引用性声明（即声明函数原型）即可

将变量和函数限制在编译单元内
- 在匿名命名空间中定义的变量和函数，都不会暴露给其他的编译单元。
```cpp
namespace { // 匿名的命名空间
  int n;
  void f() {
    n++;
  }
}
```

标准C++库  
标准C++类库是一个极为灵活并可扩展的可重用软件模块的集合。  
标准C++类与组件在逻辑上分为6种类型：  
- 输入、输出类
- 容器类与抽象数据类型
- 存储管理类
- 算法
- 错误处理
- 运行环境支持

编译预处理  
- #include 包含指令：
  - 将一个源文件嵌入到当前源文件中该点处
  - #include<文件名> 按标准方式搜索，文件位于C++系统目录的include子目录下
  - #include"文件名" 首先在当前目录中搜索，若没有，再按标准方式搜索
- #define 宏定义指令
  - 定义符号常量，很多情况下被const定义语句替代
  - 定义带参数的宏，已被内联函数取代
- #undef
  - 删除由#define定义的宏，使之不再起作用

条件编译指令：#if和 #endif
```cpp
#if 常量表达式
  // 当“常量表达式”非零时编译
  程序正文
#endif
```
也可以支持```#elif #else```

```cpp
#ifdef 标识符
  程序段1
#else
  程序段2
#endif
```

- 如果"标识符"经过#define定义过，且未经undef删除，则编译程序段1；否则编译程序段2

```cpp
#ifndef 标识符
  程序段1
#else
  程序段2
#endif
```
- 如果“标识符”未被定义过，则编译程序段1；否则编译程序段2。 可以用于避免重复包含头文件


### 5-9 小结
本章主要内容
- 对象的生存期，作用域和可见性
- 类的静态成员
- 数据的共享与保护
- 友元
- 编译预处理命令
- 多文件结构和工程

<!---

### 6-1 数组、指针与字符串导学

### 数组的定义与初始化
数组是具有一定顺序关系的若干相同类型变量的集合体，组成数组的变量称为该数组的元素

数组的定义：
类型说明符 数组名[常量表达式][常量表达式]...
数组名构成方法同一般变量名。
例如：
```
int a[10];
```
表示a为整型数组，有10个元素：a\[0\],..., a\[9\]
例如：
```
int a[5][3];
```
表示a为整型二维数组，其中第一维有5个下标，第二维有3个，数组的元素个数为15，可用于存放5行3列的整型数据表格。


数组元素的使用：
- 必须先定义，后使用
- 可以逐个引用数组元素
- 例如：
```
a[0] = a[5] + a[7] - a[2*3];
b[1][2] = a[2][3] / 2
```
### 数组作为函数的参数
- 数组元素作实参，与单个变量一样
- 数组名作参数，形、实参都是数组名，类型需要一样，传送的数组首地址。对形参数组的改变会直接影响到实参数组。


### 对象数组
- 定义对象数组：
  类型 数组名[元素个数];

- 访问对象数组元素：
  通过下标访问：数组名[下标].成员名


对象数组的初始化
- 数组中每个元素对象被创建时，系统都会调用类构造函数初始化该对象
- 通过初始化列表赋值，例如：
```
Point a[2] = {Point(1,2), Point(3,4)};
```
- 如果没有为数组元素指定显式初始值，数组元素便使用默认值初始化（调用默认构造函数）

数组元素的构造和析构
- 构造数组时，元素所属的类未声明构造函数就采用默认构造函数
- 各元素对象的初值要求为相同值时，可以声明具有默认形参的构造函数
- 各元素对象的初值要求为不同值时，需要声明带形参的构造函数
- 当数组中每一个对象被删除时，系统都要调用一次析构函数

#### 基于范围的for循环
C++11提供的新特性，自动遍历整个容器，不需要知道数组长度
```
int main()
{
int array[3] = {1,2,3};
for(int &e: array)
{
  e += 2
  std::cout << e << std::endl;
}
return 0;
}
```

### 指针的定义和运算
内存空间的访问：
- 通过变量名访问
- 通过地址访问

指针的概念：
- 指针：专门用于存储内存地址的变量，用于间接访问内存单元
- 指针变量：用于存放地址的变量

例：
```
static int i;
static int* ptr = &i;
```

```
*ptr = 3; // *ptr为指针运算，表示以ptr为内容进行寻址，找到内存单元
```

与地址相关的运算：“*”“&”  
指针运算符：*
地址运算符：&

-->
